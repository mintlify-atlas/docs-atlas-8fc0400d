---
title: "Introduction"
description: "A simple, fast, and reliable job queue for Rust applications"
---

Broccoli is a robust message queue system for Rust applications, designed as a Rust alternative to [Celery](https://docs.celeryq.dev/en/stable/getting-started/introduction.html). It provides asynchronous message processing with support for multiple message brokers.

## Features

<Columns cols={2}>
  <Card title="Async message processing" icon="bolt">
    Built on Tokio for high-performance async operations
  </Card>
  <Card title="Multiple brokers" icon="server">
    Support for Redis, RabbitMQ, and SurrealDB
  </Card>
  <Card title="Configurable retries" icon="rotate">
    Automatic retry handling with customizable strategies
  </Card>
  <Card title="Connection pooling" icon="layer-group">
    Efficient connection management out of the box
  </Card>
  <Card title="Type-safe messages" icon="shield-check">
    Leverage Rust's type system for message handling
  </Card>
  <Card title="Message scheduling" icon="clock">
    Delay and schedule messages for future processing
  </Card>
</Columns>

## Quick start

Get started with Broccoli in minutes.

<CardGroup cols={2}>
  <Card title="Installation" icon="download" href="/installation">
    Add Broccoli to your Cargo.toml
  </Card>
  <Card title="Quickstart" icon="rocket" href="/quickstart">
    Create your first producer and consumer
  </Card>
</CardGroup>

## Supported brokers

Broccoli supports multiple message brokers to fit your infrastructure needs:

| Broker | Status | Feature flag |
|--------|--------|--------------|
| Redis | Stable | `redis` (default) |
| RabbitMQ | Stable | `rabbitmq` |
| SurrealDB | Stable | `surrealdb` |

## Basic example

```rust
use broccoli_queue::queue::BroccoliQueue;
use broccoli_queue::brokers::broker::BrokerMessage;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct JobPayload {
    id: String,
    task_name: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize the queue
    let queue = BroccoliQueue::builder("redis://localhost:6379")
        .pool_connections(5)
        .failed_message_retry_strategy(Default::default())
        .build()
        .await?;

    // Publish a job
    let job = JobPayload {
        id: "job-1".to_string(),
        task_name: "process_data".to_string(),
    };
    
    queue.publish("jobs", None, &job, None).await?;

    Ok(())
}
```

## Why Broccoli?

If you're familiar with Celery but want to leverage Rust's performance and type safety, Broccoli provides:

- **Performance**: Built on Tokio for efficient async I/O
- **Type safety**: Compile-time guarantees for message structures
- **Flexibility**: Choose the message broker that fits your needs
- **Simplicity**: Clean API that gets out of your way
