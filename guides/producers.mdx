---
title: "Producers"
description: "Publish messages to queues with Broccoli"
---

Producers publish messages to queues for consumers to process. Broccoli supports single message publishing, batch publishing, and various publish options.

## Publishing a single message

Use the `publish` method to send a single message:

```rust
use broccoli_queue::queue::BroccoliQueue;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct JobPayload {
    id: String,
    task_name: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let queue = BroccoliQueue::builder("redis://localhost:6379")
        .build()
        .await?;

    let job = JobPayload {
        id: "job-1".to_string(),
        task_name: "process_data".to_string(),
    };

    // Publish returns the BrokerMessage with assigned task_id
    let message = queue.publish("jobs", None, &job, None).await?;
    println!("Published job with ID: {}", message.task_id);

    Ok(())
}
```

## Batch publishing

For better performance when publishing multiple messages, use `publish_batch`:

```rust
let jobs = vec![
    JobPayload { id: "job-1".to_string(), task_name: "task_a".to_string() },
    JobPayload { id: "job-2".to_string(), task_name: "task_b".to_string() },
    JobPayload { id: "job-3".to_string(), task_name: "task_c".to_string() },
];

let messages = queue.publish_batch("jobs", None, jobs, None).await?;

for msg in messages {
    println!("Published: {}", msg.task_id);
}
```

## Publish options

Customize message behavior with `PublishOptions`:

```rust
use broccoli_queue::queue::PublishOptions;
use time::Duration;

let options = PublishOptions::builder()
    .priority(1)                           // Priority 1-5 (1 is highest)
    .delay(Duration::seconds(30))          // Delay before processing
    .ttl(Duration::hours(1))               // Message time-to-live
    .build();

queue.publish("jobs", None, &job, Some(options)).await?;
```

### Priority levels

Messages can have priority levels from 1 (highest) to 5 (lowest):

```rust
let high_priority = PublishOptions::builder()
    .priority(1)
    .build();

let low_priority = PublishOptions::builder()
    .priority(5)
    .build();

queue.publish("jobs", None, &urgent_job, Some(high_priority)).await?;
queue.publish("jobs", None, &background_job, Some(low_priority)).await?;
```

### Delayed messages

Delay message processing by a specified duration:

```rust
use time::Duration;

let options = PublishOptions::builder()
    .delay(Duration::minutes(5))
    .build();

// This job will be available for processing in 5 minutes
queue.publish("jobs", None, &job, Some(options)).await?;
```

### Scheduled messages

Schedule a message for a specific time:

```rust
use time::OffsetDateTime;

let scheduled_time = OffsetDateTime::now_utc() + time::Duration::hours(2);

let options = PublishOptions::builder()
    .schedule_at(scheduled_time)
    .build();

queue.publish("jobs", None, &job, Some(options)).await?;
```

<Note>
Message scheduling requires enabling scheduling in the queue builder with `.enable_scheduling(true)`. For RabbitMQ, you also need the [delayed-exchange plugin](https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq).
</Note>

## Using disambiguators

Disambiguators help with fair queue processing by grouping related messages:

```rust
// Group jobs by customer ID for fair processing
queue.publish("jobs", Some("customer-123".to_string()), &job, None).await?;
queue.publish("jobs", Some("customer-456".to_string()), &other_job, None).await?;
```

This ensures that jobs from different customers are processed fairly, rather than one customer's jobs dominating the queue.

## Canceling messages

Cancel a published message before it's processed:

```rust
let message = queue.publish("jobs", None, &job, None).await?;

// Later, cancel the job if needed
queue.cancel("jobs", message.task_id.to_string()).await?;
```

## Error handling

Handle publishing errors appropriately:

```rust
use broccoli_queue::error::BroccoliError;

match queue.publish("jobs", None, &job, None).await {
    Ok(message) => {
        println!("Published: {}", message.task_id);
    }
    Err(BroccoliError::Publish(msg)) => {
        eprintln!("Failed to publish: {}", msg);
    }
    Err(e) => {
        eprintln!("Unexpected error: {:?}", e);
    }
}
```

## Next steps

<CardGroup cols={2}>
  <Card title="Consumers" icon="download" href="/guides/consumers">
    Process published messages
  </Card>
  <Card title="Message scheduling" icon="clock" href="/guides/message-scheduling">
    Advanced scheduling options
  </Card>
</CardGroup>
