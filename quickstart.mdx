---
title: "Quickstart"
description: "Create your first Broccoli producer and consumer"
---

This guide walks you through creating a basic job queue with a producer that publishes jobs and a consumer that processes them.

## Prerequisites

- Broccoli installed (see [Installation](/installation))
- Redis running locally (or another supported broker)

## Define your job payload

First, create a struct that represents your job data. This struct must implement `Serialize` and `Deserialize`:

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct JobPayload {
    id: String,
    task_name: String,
}
```

## Create a producer

The producer publishes jobs to the queue:

```rust
use broccoli_queue::queue::BroccoliQueue;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct JobPayload {
    id: String,
    task_name: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize the queue
    let queue = BroccoliQueue::builder("redis://localhost:6379")
        .pool_connections(5)
        .failed_message_retry_strategy(Default::default())
        .build()
        .await?;

    // Create jobs
    let jobs = vec![
        JobPayload {
            id: "job-1".to_string(),
            task_name: "process_data".to_string(),
        },
        JobPayload {
            id: "job-2".to_string(),
            task_name: "generate_report".to_string(),
        },
    ];

    // Publish jobs in batch
    queue.publish_batch("jobs", None, jobs, None).await?;
    
    println!("Jobs published successfully!");
    Ok(())
}
```

## Create a consumer

The consumer processes jobs from the queue:

```rust
use broccoli_queue::queue::BroccoliQueue;
use broccoli_queue::brokers::broker::BrokerMessage;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct JobPayload {
    id: String,
    task_name: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize the queue
    let queue = BroccoliQueue::builder("redis://localhost:6379")
        .pool_connections(5)
        .failed_message_retry_strategy(Default::default())
        .build()
        .await?;

    // Process messages with 2 concurrent workers
    queue.process_messages(
        "jobs",
        Some(2),
        None,
        |message: BrokerMessage<JobPayload>| async move {
            println!("Processing job: {} - {}", message.payload.id, message.payload.task_name);
            
            // Your job processing logic here
            
            Ok(())
        },
    ).await?;

    Ok(())
}
```

## Run the example

<Steps>
  <Step title="Start Redis">
    ```bash
    docker run -d -p 6379:6379 redis
    ```
  </Step>
  <Step title="Run the consumer">
    In one terminal, start the consumer:
    ```bash
    cargo run --bin consumer
    ```
  </Step>
  <Step title="Run the producer">
    In another terminal, publish jobs:
    ```bash
    cargo run --bin producer
    ```
  </Step>
</Steps>

You should see the consumer processing the jobs as they arrive.

## Using custom handlers

For more control over success and error handling, use `process_messages_with_handlers`:

```rust
use broccoli_queue::queue::BroccoliQueue;
use broccoli_queue::brokers::broker::BrokerMessage;
use broccoli_queue::error::BroccoliError;

queue.process_messages_with_handlers(
    "jobs",
    Some(3),
    None,
    // Message handler
    |message: BrokerMessage<JobPayload>| async move {
        println!("Processing: {}", message.payload.id);
        Ok(())
    },
    // Success handler
    |message, _result| async move {
        println!("Completed: {}", message.payload.id);
        Ok(())
    },
    // Error handler
    |message, error| async move {
        eprintln!("Failed {}: {:?}", message.payload.id, error);
        Ok(())
    },
).await?;
```

## Next steps

<CardGroup cols={2}>
  <Card title="Producers" icon="upload" href="/guides/producers">
    Learn about publishing options and batch operations
  </Card>
  <Card title="Consumers" icon="download" href="/guides/consumers">
    Configure consumer behavior and concurrency
  </Card>
  <Card title="Retry strategies" icon="rotate" href="/guides/retry-strategies">
    Handle failed messages with retries
  </Card>
  <Card title="Message scheduling" icon="clock" href="/guides/message-scheduling">
    Delay and schedule messages
  </Card>
</CardGroup>
